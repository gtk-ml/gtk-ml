(define (= a b) (cmp 0 a b))
(define (> a b) (cmp 3 a b))
(define (cdar list) (car (cdr list)))
(define (cddar list) (car (cdr (cdr list))))

; returns true if expression is an int or a float
(define (number? expr)
  (cond
    (= (typeof expr) :int)   #t
    (= (typeof expr) :float) #t
    :else                    #f))

; returns true if expression is a non-empty list
(define (list? expr) (= (typeof expr) :list))
(define (nil? expr) (= (typeof expr) :nil))
(define (empty? container) (= (len container) 0))

(define (= a b) (cmp 0 a b))

(define (get-and-inc v)
  (let [value @v]
    (assign v (+ @v 1))
    value))

(define (reverse-index array ridx) (index array (- (len array) ridx)))

(define (unsigned->string* acc num rest digit)
  (cond
    (= num 0) acc
    (= digit 0) (unsigned->string* (push acc \0) (/ num 10) (/ rest 10) (% rest 10))
    (= digit 1) (unsigned->string* (push acc \1) (/ num 10) (/ rest 10) (% rest 10))
    (= digit 2) (unsigned->string* (push acc \2) (/ num 10) (/ rest 10) (% rest 10))
    (= digit 3) (unsigned->string* (push acc \3) (/ num 10) (/ rest 10) (% rest 10))
    (= digit 4) (unsigned->string* (push acc \4) (/ num 10) (/ rest 10) (% rest 10))
    (= digit 5) (unsigned->string* (push acc \5) (/ num 10) (/ rest 10) (% rest 10))
    (= digit 6) (unsigned->string* (push acc \6) (/ num 10) (/ rest 10) (% rest 10))
    (= digit 7) (unsigned->string* (push acc \7) (/ num 10) (/ rest 10) (% rest 10))
    (= digit 8) (unsigned->string* (push acc \8) (/ num 10) (/ rest 10) (% rest 10))
    (= digit 9) (unsigned->string* (push acc \9) (/ num 10) (/ rest 10) (% rest 10))
    :else       (error '{:err digit-error :desc "number is not a digit" :value digit})))

(define (rev-array* acc array)
  (cond
    (empty? array) acc
    :else          (rev-array* (push acc (reverse-index array 1)) (pop array))))

(define (rev-array array)
  (rev-array* [] array))

(define (unsigned->string num)
  (rev-array (unsigned->string* "" num (/ num 10) (% num 10))))

(define (format-v-impl acc offset fmt args)
  (cond
    (= offset (len fmt))
      (cond
        (nil? args) acc
        :else       (error '{:err arity-error :desc "too many format arguments"}))
    (> offset (len fmt))
      (error {:err 'index-out-of-bounds :desc "fmt offset is greater than (len fmt)" :len (len fmt) :offset offset})
    (= (index fmt offset) \~)
      (cond
        (= (+ offset 1) (len fmt))
          (error {:err 'fmt-error :desc "invalid format string" :char (index fmt (+ offset 1))})
        (= (index fmt (+ offset 1)) \a)
          (cond
            (nil? args) (error '{:err arity-error :desc "too few format arguments"})
            :else       (format-v-impl (concat acc (car args)) (+ offset 2) fmt (cdr args)))
        (= (index fmt (+ offset 1)) \u)
          (cond
            (nil? args) (error '{:err arity-error :desc "too few format arguments"})
            :else       (format-v-impl (concat acc (unsigned->string (car args))) (+ offset 2) fmt (cdr args)))
        :else
          (error {:err 'fmt-error :desc "invalid format string" :char (index fmt (+ offset 1))}))
    :else
      (format-v-impl (push acc (index fmt offset)) (+ offset 1) fmt args)))

(define (format-v fmt args)
  (format-v-impl "" 0 fmt args))

(define (format fmt ...args) (format-v fmt args))

; returns true if expression is a constant number or an expression that evaluates to a constant number
(define (const-number? expr)
  (cond
    (number? expr) #t
    (list? expr)   (cond
      (= (car expr) 'intr-add) (cond
        (const-number? (cdar expr)) (const-number (cddar expr))
        :else #f))
    :else          #f))

; evaluates a constant expression
(define (const-eval expr)
  (cond
    (number? expr) expr
    (list? expr)   (cond
      (= (car expr) 'intr-add) (+ (const-eval (cdar expr)) (const-eval (cddar expr)))
      :else                    #nil)
    :else          expr))

; define an intrinsical operator
(define-intrinsic (intr-add a b)
  (cond
    (const-number? a) (cond
      (const-number? b) (emit-bytecode CTX CODE-BUILDER @BASIC-BLOCK cond-none :push-imm (+ (const-eval a) (const-eval b)))
      :else (do
        (compile-expr CTX CODE-BUILDER BASIC-BLOCK b)
        (compile-expr CTX CODE-BUILDER BASIC-BLOCK a)
        (emit-bytecode CTX CODE-BUILDER @BASIC-BLOCK cond-none :add)))
    :else (do
      (compile-expr CTX CODE-BUILDER BASIC-BLOCK b)
      (compile-expr CTX CODE-BUILDER BASIC-BLOCK a)
      (emit-bytecode CTX CODE-BUILDER @BASIC-BLOCK cond-none :add))))

(define (sum a ...rest)
  (cond
    (nil? rest) a
    :else       (+ a (sum (car rest) ...(cdr rest)))))

; define a Window macro
(define-macro (Window title width height ...body)
  `(lambda (app)
    (new-window app ,title ,width ,height)
    ,...body))

; run the application
(Application "de.walterpi.example" flags-none {
  :activate (Window
    ;; title
    (format "~a ~u" "window" 42) 
    ;; width
    (cond
      #f          (error {:err 'cond-error :desc "cond evaluated in an incorrect way"})
      (cmp 0 1 2) (error {:err 'cond-error :desc "cond evaluated in an incorrect way"})
      :else       (sum 160 160 160 160))
    ;; height
    (do 0 (intr-add 240 240)))})
